"""
Command execution routes for Grok-Pilot.
Handles text commands and tool execution.
"""

import json
from flask import Blueprint, request, jsonify, current_app
from core.logger import get_logger
from utils.helpers import format_tool_results
from ai.prompts import DRONE_PILOT_SYSTEM_PROMPT

commands_bp = Blueprint('commands', __name__)
log = get_logger('routes.commands')


@commands_bp.route('/', methods=['POST'])
def execute_command():
    """
    Execute a text command using Grok AI with tools.
    
    Request JSON:
        {
            "text": "take off and look around"
        }
    
    Response JSON:
        {
            "status": "success",
            "response": "AI response text",
            "tool_results": [...]
        }
    """
    try:
        # Check Content-Type
        if not request.is_json:
            return jsonify({
                'error': 'Content-Type must be application/json',
                'status': 'error'
            }), 400
        
        # Parse JSON with better error handling
        try:
            data = request.get_json(force=True)
        except Exception as e:
            return jsonify({
                'error': f'Invalid JSON: {str(e)}',
                'status': 'error'
            }), 400
        
        if not data or 'text' not in data:
            return jsonify({
                'error': 'Missing "text" field',
                'status': 'error'
            }), 400
        
        text = data['text'].strip()
        if not text:
            return jsonify({
                'error': 'Empty command',
                'status': 'error'
            }), 400
        
        log.info(f"Command received: {text}")
        
        # Build messages for Grok with proper system prompt
        messages = [
            {"role": "system", "content": DRONE_PILOT_SYSTEM_PROMPT},
            {"role": "user", "content": text}
        ]
        
        # Call Grok with tools
        result = current_app.grok.chat_with_tools(
            messages=messages,
            tools=current_app.tools.get_schemas()
        )
        
        # Log the AI response
        if result.get('response'):
            log.info(f"ü§ñ AI Response: {result['response']}")
        
        # Log ALL tool calls that Grok generated (before execution)
        tool_calls = result.get('tool_calls', [])
        if tool_calls:
            log.info("=" * 60)
            log.info(f"üß† GROK GENERATED {len(tool_calls)} TOOL CALL(S):")
            log.info("=" * 60)
            for i, call in enumerate(tool_calls, 1):
                args_str = json.dumps(call['arguments']) if call['arguments'] else "()"
                log.info(f"  [{i}] {call['name']}({args_str})")
            log.info("=" * 60)
        else:
            log.warning("‚ö†Ô∏è No tool calls generated by Grok!")
        
        # Execute any tool calls
        tool_results = []
        if tool_calls:
            for i, call in enumerate(tool_calls, 1):
                args_str = json.dumps(call['arguments']) if call['arguments'] else "()"
                log.info(f"‚ñ∂Ô∏è Executing [{i}/{len(tool_calls)}]: {call['name']}({args_str})")
                
                try:
                    tool_result = current_app.tools.execute(
                        call['name'],
                        **call['arguments']
                    )
                    
                    status = "‚úÖ" if tool_result.success else "‚ùå"
                    log.info(f"   {status} Result: {tool_result.message}")
                    
                    tool_results.append({
                        'tool': call['name'],
                        'arguments': call['arguments'],
                        'success': tool_result.success,
                        'message': tool_result.message,
                        'data': tool_result.data
                    })
                except Exception as e:
                    log.error(f"   ‚ùå Tool execution failed: {e}")
                    tool_results.append({
                        'tool': call['name'],
                        'arguments': call['arguments'],
                        'success': False,
                        'message': str(e),
                        'data': None
                    })
        
        # Format response
        response_text = result.get('response', '')
        if tool_results:
            response_text += "\n\n" + format_tool_results(tool_results)
        
        return jsonify({
            'status': 'success',
            'response': response_text,
            'tool_results': tool_results
        })
    
    except Exception as e:
        log.error(f"Command execution failed: {e}")
        return jsonify({
            'status': 'error',
            'error': str(e)
        }), 500


@commands_bp.route('/raw', methods=['POST'])
def execute_raw_code():
    """
    Execute raw Python code (for debugging/testing).
    
    Request JSON:
        {
            "code": "drone.move('forward', 50)"
        }
    """
    try:
        data = request.get_json()
        if not data or 'code' not in data:
            return jsonify({'error': 'Missing "code" field'}), 400
        
        code = data['code']
        log.warning(f"Executing raw code: {code[:100]}...")
        
        # Execute in safety sandbox
        from drone.safety import SafetyExecutor
        executor = SafetyExecutor(current_app.drone, current_app.tools)
        result = executor.execute(code)
        
        return jsonify({
            'status': 'success' if result.success else 'error',
            'message': result.message,
            'output': result.output
        })
    
    except Exception as e:
        log.error(f"Raw code execution failed: {e}")
        return jsonify({
            'status': 'error',
            'error': str(e)
        }), 500
